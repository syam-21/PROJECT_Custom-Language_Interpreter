%{
#include <stdio.h>
#include <stdlib.h> // For atof, atoi, malloc, free
#include <string.h> // For strdup
#include "semantic_action_simulator.tab.h" // Generated by bison

extern YYSTYPE yylval; // Must be here for Bison generated header

%}

%option noyywrap
%option yylineno

%%

[ \t\r]+        ; // Ignore whitespace

"/\*"[^*]*"*"*\+\*\/    ; // Multi-line comments - simplified
"//".*          ; // Single-line comments

"char"          { yylval.str_val = strdup(yytext); return TYPE_CHAR; }
"const"         return CONST_QUALIFIER;
"double"        { yylval.str_val = strdup(yytext); return TYPE_DOUBLE; }
"float"         { yylval.str_val = strdup(yytext); return TYPE_FLOAT; }
"int"           { yylval.str_val = strdup(yytext); return TYPE_INT; }
"long"          { yylval.str_val = strdup(yytext); return TYPE_LONG; }
"short"         { yylval.str_val = strdup(yytext); return TYPE_SHORT; }
"signed"        return SIGNED_QUALIFIER;
"unsigned"      return UNSIGNED_QUALIFIER;
"void"          { yylval.str_val = strdup(yytext); return TYPE_VOID; } // Though we ignore void types for assignment simulation

"if"            return IF_KEYWORD;
"else"          return ELSE_KEYWORD;
"while"         return WHILE_KEYWORD;
"for"           return FOR_KEYWORD;
"return"        return RETURN_KEYWORD;
"main"          return MAIN_KEYWORD;
"printf"        return PRINTF_KEYWORD; // For #include

[a-zA-Z_][a-zA-Z0-9_]*  { yylval.str_val = strdup(yytext); return IDENTIFIER; }

// Literals
[0-9]+\.[0-9]*([Ee][+-]?[0-9]+)? { yylval.fval = atof(yytext); return FLOAT_LITERAL; }
[0-9]+          { yylval.ival = atoi(yytext); return INT_LITERAL; }
'(.|\n)?'  { yylval.cval = yytext[1]; return CHAR_LITERAL; } // Simple char literal: 'a'
"([^"\\]|\\.)*" { yylval.str_val = strdup(yytext); return STRING_LITERAL; } // String literals

// Operators and Punctuation
"+"             return ADD;
"-"             return SUB;
"*"             return ASTERISK; // Used for multiplication and pointers
"/"             return DIV;
"="             return ASSIGN;
"=="            return EQ_OP;
"!="            return NE_OP;
"<"             return LT_OP;
">"             return GT_OP;
"<="            return LE_OP;
">="            return GE_OP;
"&&"            return AND_OP;
"||"            return OR_OP;
"!"             return NOT_OP;
"&"             return AMPERSAND; // For address-of/bitwise AND
"%"             return MOD; // Added Modulo

"("             return LPAREN;
")"             return RPAREN;
"{"             return LBRACE;
"}"             return RBRACE;
"["             return LBRACKET;
"]"             return RBRACKET;
";"             return SEMICOLON;
","             return COMMA;
"\n"            return EOL; // End of line for statement separation
"#".*           ; // Ignore preprocessor directives like #include (just the line)

.               { fprintf(stderr, "LEXICAL ERROR: Unrecognized character: %s at line %d\n", yytext, yylineno); }

%%
