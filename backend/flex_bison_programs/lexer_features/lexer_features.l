%{
#include <stdio.h>
#include <string.h>
#include <stdlib.h> // For atoi, atof, strdup
#include "lexer_features.tab.h" // Generated by Bison
extern YYSTYPE yylval;

int token_count = 0;
%}

%option noyywrap

%%

^#.*          { /* Ignore preprocessor directives */ }
"//".*         { /* Ignore single-line comments */ }
"/*"([^*]|\*+[^*/])*\**"*/" { /* Ignore multi-line comments */ }

"if"            { token_count++; return IF_KW; }
"else"          { token_count++; return ELSE_KW; }
"while"         { token_count++; return WHILE_KW; }
"for"           { token_count++; return FOR_KW; }
"int"           { token_count++; return TYPE_INT; }
"float"         { token_count++; return TYPE_FLOAT; }
"string"        { token_count++; return TYPE_STRING; }
"return"        { token_count++; return RETURN_KW; }

[a-zA-Z_][a-zA-Z0-9_]* { token_count++; yylval.str_val = strdup(yytext); return IDENTIFIER; }

([0-9]+(\.[0-9]*)?|\.[0-9]+) { token_count++; yylval.float_val = atof(yytext); return NUMBER; }

\"(\\.|[^"\\])*\" { token_count++; yylval.str_val = strdup(yytext); return STRING_LITERAL; }

"+"             { token_count++; return OP_PLUS; }
"-"             { token_count++; return OP_MINUS; }
"*"             { token_count++; return OP_MUL; }
"/"             { token_count++; return OP_DIV; }
"="             { token_count++; return OP_ASSIGN; }
"=="            { token_count++; return OP_EQ; }
"!="            { token_count++; return OP_NE; }
"<"             { token_count++; return OP_LT; }
">"             { token_count++; return OP_GT; }
"<="            { token_count++; return OP_LE; }
">="            { token_count++; return OP_GE; }
"&&"            { token_count++; return OP_AND; }
"||"            { token_count++; return OP_OR; }
"!"             { token_count++; return OP_NOT; }

"("             { token_count++; return DEL_LP; }
")"             { token_count++; return DEL_RP; }
"{"             { token_count++; return DEL_LC; }
"}"             { token_count++; return DEL_RC; }
"["             { token_count++; return DEL_LB; }
"]"             { token_count++; return DEL_RB; }
";"             { token_count++; return DEL_SEMICOLON; }
","             { token_count++; return DEL_COMMA; }
"."             { token_count++; return DEL_DOT; }

[ \t\r\n]+      { /* Ignore whitespace and newlines */ }

.               { token_count++; fprintf(stderr, "LEXICAL ERROR: Unrecognized character: %s\n", yytext); }

%%

// int yywrap() is not needed with %option noyywrap
// A simple main for testing Flex separately (not used when integrated with Bison) 
/*
int main(int argc, char **argv) {
    if (argc > 1) {
        yyin = fopen(argv[1], "r");
        if (!yyin) {
            perror(argv[1]);
            return 1;
        }
    }
    yylex();
    printf("Total tokens: %d\n", token_count);
    return 0;
}
*/
